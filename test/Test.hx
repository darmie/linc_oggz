package;

import cpp.VirtualArray.NativeVirtualArray;
import cpp.UInt64;
import cpp.Float64;
import cpp.UInt8;
import haxe.io.BytesData;
import cpp.ArrayBase;
import cpp.Char;
import cpp.Pointer;
import cpp.SizeT;
import cpp.NativeArray;
import ogg.OggPage.OggPacket;
import haxe.io.BytesBuffer;
import cpp.Callable;
import haxe.io.Bytes;
import cpp.RawPointer;
import oggz.Oggz;
import oggz.Oggz.Long;
import cpp.Int64;




function FAIL(str:String) {
	Sys.println('FAIL: $str');
	Sys.exit(1);
}

function WARN(str:String) {
	Sys.println('WARN: $str');
}

function INFO(str:String) {
	Sys.println('INFO: $str');
}

function MIN(a:Float, b:Float):Float {
	return Math.min(a, b);
}

@:keepSub
class Test {
	static var serialno:Int64;
	static var bytes_generated:Int = 0;
	static var read_called:Int64 = 0;
	static var eof_reached:Int64 = 0;

	static final DATA_BUF_LEN:Int = 1024;

	static function main() {
		io_read_single();
	}

	static function io_read_single() {
		var n:Long = 0, ret:Long = 0;
		INFO("Testing override of IO reading");

		var data_buf:RawPointer<UInt8> = Pointer.fromRaw(NativeArray.getBase(Bytes.alloc(DATA_BUF_LEN).getData()).getBase()).rawCast();

		var writer = Oggz.init(OGGZ_WRITE);
		if (writer == null) {
			FAIL("newly created OGGZ writer == NULL");
		}
		serialno = Oggz.serialno_new(writer);

		if (Oggz.write_set_hungry_callback(writer, Callable.fromStaticFunction(hungry), 1, null) == -1) {
			FAIL("Could not set hungry callback");
		}

		var reader = Oggz.init(OGGZ_READ);
		if (reader == null) {
			FAIL("newly created OGGZ reader == NULL");
		}
		Oggz.io_set_read(reader, Callable.fromStaticFunction(my_io_read), data_buf);
        Oggz.set_read_callback(reader, -1, Callable.fromStaticFunction(read_packet), null);
        n = Oggz.write_output(writer, data_buf, DATA_BUF_LEN);

        
        if (untyped __cpp__("n >= DATA_BUF_LEN"))
            FAIL("Too much data generated by writer");

        bytes_generated = n;

        do {
          ret = Oggz.read(reader, 4);
        } while (untyped __cpp__("ret > 0 || ret == -14"));

        if (ret != 0) FAIL ("oggz_read didn't reach EOF");

        if (eof_reached == 0) FAIL ("oggz_read returned 0 before EOF");
      
        if (read_called == 0)
          FAIL("Read method ignored");
      
        if (Oggz.close (reader) != 0)
          FAIL("Could not close OGGZ reader");
      
        if (Oggz.close (writer) != 0)
          FAIL("Could not close OGGZ writer");

        Sys.exit(0);
	}



	static function hungry(oggz:RawPointer<Oggz>, empty:Int, user_data:RawPointer<cpp.Void>):Int {
		var buf:Array<UInt8> = [];

		var op = OggPacket.init();

        untyped __cpp__("
            static int iter = 0;
            static long b_o_s = 1;
            static long e_o_s = 0");

		if (untyped __cpp__("iter > 10"))
			return 1;
		var s:UInt8 = untyped __cpp__("'a'+iter");
		
		buf[0] = s;

		op.packet = Pointer.ofArray(buf).rawCast();
		op.bytes = 1;
		op.b_o_s = untyped __cpp__("b_o_s");
		op.e_o_s = untyped __cpp__("e_o_s");
		op.granulepos = untyped __cpp__("iter");
		op.packetno = untyped __cpp__("iter");

		/* Main check */
		if (Oggz.write_feed(oggz, RawPointer.addressOf(op), serialno, 0, null) != 0)
			FAIL("Oggz write failed");

        untyped __cpp__("iter++");
        untyped __cpp__("b_o_s = 0");
        if (untyped __cpp__("iter") == 10) untyped __cpp__("e_o_s = 1");
		return 0;
	}

	static function my_io_read(user_handle:RawPointer<cpp.Void>, buf:RawPointer<cpp.Void>, n:SizeT):SizeT {
		var data_buf:RawPointer<UInt8> = Pointer.fromRaw(user_handle).rawCast();

        
		//var offset= 0;
		untyped  __cpp__("static int offset = 0");

		var len = 0;

		/* Mark that the read IO method was actually used */
		read_called++;

		len =  Math.round(Math.abs(MIN(n, bytes_generated - untyped __cpp__("offset"))));

		//var _buf:RawPointer<UInt8> = Pointer.fromRaw(buf).rawCast();

		untyped __cpp__("memcpy (buf, &data_buf[offset], len)");

		untyped __cpp__("offset += len");
		//offset = len + 1;

		if (len == 0)
			eof_reached = 1;
		return len;
	}


	static function read_packet(oggz:RawPointer<Oggz>, zp:RawPointer<Packet>, serialno:Long, user_data:RawPointer<cpp.Void>):Int {
		var op = Pointer.fromRaw(zp).ref.op;

        untyped __cpp__("
            static int iter = 0;
            static long b_o_s = 1;
            static long e_o_s = 0");

		#if debug
		Sys.print('${Oggz.tell(oggz)}, x: serialno ${serialno.toInt64()}, granulepos ${op.granulepos}, packetno ${op.packetno}');
		if (op.b_o_s == 0) {
			Sys.print(" *** bos");
		}

		if (op.e_o_s == 0) {
			Sys.print(" *** eos");
		}
        Sys.println("");
		#end
        if (op.bytes != 1)
            FAIL ("Packet too long");
		
		final contains = untyped __cpp__("{0}[0] != 'a'+iter", op.packet);
        if (contains)
            FAIL ("Packet contains incorrect data");
        
        if ((op.b_o_s == 0) != (untyped __cpp__("b_o_s == 0")))
            FAIL ("Packet has incorrect b_o_s");
        
        if ((op.e_o_s == 0) != (untyped __cpp__("e_o_s == 0")))
            FAIL ("Packet has incorrect e_o_s");
        
        if (op.granulepos != -1 && op.granulepos != untyped __cpp__("iter"))
            FAIL ("Packet has incorrect granulepos");
        
        if (op.packetno != untyped __cpp__("iter"))
            FAIL ("Packet has incorrect packetno");  
        
        
    
        untyped __cpp__("iter++");
        untyped __cpp__("b_o_s = 0");
        if (untyped __cpp__("iter") == 10) untyped __cpp__("e_o_s = 1");
        
        return OGGZ_STOP_OK;
	}
}

